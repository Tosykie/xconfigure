# Arch file targeting Linux 64-bit using the Intel tool chain
#
PERL          = perl
# use compiler to preprocess Fortran code
CPP           = $(NULL)
ACC           = $(NULL)
OFFLOAD_CC    = $(NULL)
OFFLOAD_FLAGS = $(NULL)
DFLAGS        = __NO_IPI_DRIVER __DBCSR_DISABLE_WORKSHARE
#CSTD          = -std=c99
#CSTD          = -std=c11
CFLAGS        = $(CSTD)
IFLAGS        = $(NULL)
CXXFLAGS      = $(NULL)
FCFLAGS       = $(NULL)
LDFLAGS       = $(NULL)
ACCFLAGS      = $(NULL)
LIBS          = $(NULL)
LIBDIRNAME    = lib
OBJDIRNAME    = obj
EXTSDIR       = exts

# Special characters
CHAR_HASH := \#

# LIBXSMM (https://github.com/hfp/libxsmm)
#LIBXSMMROOT := /path/to/libxsmm

# LIBINT: https://xconfigure.readthedocs.io/libint/
#LIBINTROOT := /path/to/libint

# PLUMED: https://xconfigure.readthedocs.io/plumed/
#PLUMEDROOT := /path/to/plumed

# LIBXC: https://xconfigure.readthedocs.io/libxc/
#LIBXCROOT := /path/to/libxc

# ELPA: https://xconfigure.readthedocs.io/elpa/
#ELPAROOT := /path/to/elpa

# calculate version number given by up to three components
version = $(shell echo "$$(( \
  $(if $(strip $1),$(word 1,$1)*10000,0) + \
  $(if $(strip $2),$2*100,$(if $(word 2,$1),$(word 2,$1)*100,0)) + \
  $(if $(strip $3),$3,$(if $(word 3,$1),$(word 3,$1),0))))")

WHICH := $(shell which which 2>/dev/null || echo "command -v")
which = $(shell $(WHICH) 2>/dev/null $(firstword $1))

prefix_iflags = $(addprefix -I,$1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15} ${16})
prefix_dflags = $(addprefix -D,$1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15} ${16})

# Automatically pickup the environment (make -e is not required),
# or pickup the Intel Compiler (if available).
GNU ?= 0
ifeq (0,$(GNU))
  ifeq (,$(shell echo "$${FC}"))
    ifneq (,$(filter ifx ifx2,$(notdir $(call which,ifx))$(INTEL)))
      FC := ifx
    else ifneq (,$(filter ifort ifort1,$(notdir $(call which,ifort))$(INTEL)))
      FC := ifort
    endif
  endif
  ifeq (,$(shell echo "$${CXX}"))
    ifneq (,$(filter icpx icpx2,$(notdir $(call which,icpx))$(INTEL)))
      CXX := icpx
    else ifneq (,$(filter icpc icpc1,$(notdir $(call which,icpc))$(INTEL)))
      CXX := icpc
    endif
  endif
  ifeq (,$(shell echo "$${CC}"))
    ifneq (,$(filter icx icx2,$(notdir $(call which,icx))$(INTEL)))
      CC := icx
    else ifneq (,$(filter icc icc1,$(notdir $(call which,icc))$(INTEL)))
      CC := icc
    endif
  endif
endif

# check if the Intel Development Tools are available
INTEL ?= $(strip $(if $(filter icc% icx% Intel%, \
  $(shell $(CC) --version 2>/dev/null | head -n1 | cut -d' ' -f1)), \
  $(if $(call which,ifx), 2, 1), 0))

ifneq (0,$(INTEL))
  CFG := intel
  GNU := 0
else
  CFG := gnu
  GNU := 1
endif

# DEFAULTS
#
SSE ?= 0
AVX ?= 0
MPI ?= 1
OMP ?= 1
DBG ?= 0
SYM ?= $(DBG)
FPE ?= 0
VMAX ?= 0
MKL_DIRECT ?= 0
MKL_STATIC ?= 1

# NDEBUG=0: keep all assertions active
# NDEBUG=1: apply to DBCSR (should be fine)
# NDEBUG=2: plus CP2K (regtests may fail)
ifeq (0,$(DBG)) # production code
  NDEBUG ?= 1
else
  NDEBUG ?= 0
endif

EXTSHOME ?= $(CP2KHOME)/$(EXTSDIR)
EXTDBCSR ?= $(EXTSHOME)/dbcsr
DBCSRSRC ?= $(EXTDBCSR)/src
LEGACY ?= $(if $(wildcard $(EXTDBCSR)),0,1)
UNAME ?= $(shell uname 2>/dev/null)

ifeq (0,$(LEGACY))
  IFLAGS += $(CP2KHOME)/$(OBJDIRNAME)/$(ARCH)/$(ONEVERSION)/exts/dbcsr
  ELPA ?= 1
else # legacy
  ELPA ?= 201705
endif

ifneq (,$(LIBXSMM))
ifneq (0,$(shell echo "$$((2 < $(LIBXSMM)))"))
  IPO ?= 0
endif
endif
ifeq (0,$(GNU))
  OMPRT ?= iomp5
  ifeq (1,$(INTEL))
    MATMUL ?= 0
  endif
else # GNU
  OMPRT ?= gomp
endif
MATMUL ?= 1
IPO ?= 0

ifneq (0,$(OMP))
  MKL ?= 2
else ifneq (0,$(MPI))
  MKL ?= 1
else
  MKL ?= 2
endif

# consider more accurate FP-model
#FPCMODEL := fast=2
#FPFMODEL := fast=2

# advanced compiler flags
ifneq (0,$(INTEL))
  ifeq (1,$(INTEL))
    FCFLAGS += -complex-limited-range
    #FCFLAGS += -fimf-domain-exclusion=1
    #FCFLAGS += -fast-transcendentals
  endif
  #FCFLAGS += -nostandard-realloc-lhs
endif

SCALAPACK ?= $(MPI)
ifneq (0,$(MPI))
  ifeq (0,$(GNU))
    ifeq (1,$(INTEL)) # fallback to next-gen in case of C/C++
      CXX := mpiicpc $(if $(call which,icpc),$(NULL),-cxx=icpx)
      CC  := mpiicc  $(if $(call which,icc),$(NULL),-cc=icx)
      FC  := mpiifort
      LD  := mpiifort
    else
      CXX := mpiicpc  -cxx=icpx
      CC  := mpiicc   -cc=icx
      FC  := mpiifort -fc=ifx
      LD  := mpiifort -fc=ifx
    endif
  else # GNU
    CXX := mpicxx
    CC  := mpicc
    FC  := mpif90
    LD  := mpif90
  endif
  DFLAGS += __parallel
  ifneq (1,$(MPI))
    DFLAGS += __MPI_VERSION=$(MPI)
  else # default MPI std. version
    DFLAGS += __MPI_VERSION=3
  endif
else ifeq (0,$(GNU))
  ifeq (1,$(INTEL)) # fallback to next-gen in case of C/C++
    CXX := $(if $(call which,icpc),icpc,icpx)
    CC  := $(if $(call which,icc),icc,icx)
    FC  := ifort
    LD  := ifort
  else
    CXX := icpx
    CC  := icx
    FC  := ifx
    LD  := ifx
  endif
else # GNU
  CXX := g++
  CC  := gcc
  FC  := gfortran
  LD  := gfortran
endif
XCXX := $(CXX)
XCC := $(CC)
XFC := $(FC)

OCL ?= 0
CUDA ?= 0
ifeq (opencl,$(USE_ACCEL))
  OCL := 2
else ifeq (cuda,$(USE_ACCEL))
  CUDA := 1
else ifneq (,$(USE_ACCEL))
  $(info ============================)
  $(info USE_ACCEL=$(USE_ACCEL) not supported!)
  $(info ============================)
  $(error USE_ACCEL)
endif

NVCC_FILE := $(call which,nvcc)
NVCC := $(notdir $(NVCC_FILE))
NVCC_PATH := $(if $(NVCC_FILE),$(wildcard $(dir $(NVCC_FILE))/..))
CUDA_FILE := $(wildcard $(NVCC_PATH)/../cuda/include/cuda.h)
CUDA_PATH := $(if $(CUDA_FILE),$(NVCC_PATH)/../cuda,$(NVCC_PATH))
CUDA_LIBS := $(if $(wildcard $(CUDA_PATH)/lib64),lib64,lib)

# MKL_MPIRTL: intelmpi, openmpi
MKL_MPIRTL ?= $(if $(I_MPI_ROOT),intelmpi,openmpi)
ifneq (0,$(BLAS))
  ifneq (Darwin,$(UNAME))
    MKL_PLATFORM := linux
  else # OSX
    MKL_PLATFORM := mac
  endif
endif

# enable MKL if available
ifeq (,$(strip $(MKLROOT)))
  MKL_INCFILE := $(strip $(lastword $(sort $(wildcard /opt/intel/compilers_and_libraries_*/$(MKL_PLATFORM)/mkl/include/mkl.h))))
  ifneq (,$(MKL_INCFILE))
    MKLROOT := $(abspath $(dir $(MKL_INCFILE))/..)
  endif
endif
ifeq (,$(strip $(MKLROOT)))
  MKL_INCFILE := $(strip $(wildcard /usr/include/mkl/mkl.h))
  ifneq (,$(MKL_INCFILE))
    MKLROOT := $(abspath $(dir $(MKL_INCFILE))/../..)
  endif
endif
ifeq (/,$(MKLROOT))
  MKL_INCFILE := $(NULL)
  MKLROOT := $(NULL)
endif

# COSMA section must appear before SCALAPACK section
ifneq (0,$(COSMA)) # incl. undefined
ifneq (0,$(MPI))
  ifneq (,$(NVCC))
    COSMATGT := gpu
  else
    COSMATGT := cpu
  endif
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(CP2KHOME)/../cosma*$(COSMATGT)/lib*/libcosma_pxgemm_cpp.*)))
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(HOME)/cosma*$(COSMATGT)/lib*/libcosma_pxgemm_cpp.*)))
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(CP2KHOME)/../cosma*/$(COSMATGT)/lib*/libcosma_pxgemm_cpp.*)))
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(HOME)/cosma*/$(COSMATGT)/lib*/libcosma_pxgemm_cpp.*)))
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(CP2KHOME)/../cosma*/lib*/libcosma_pxgemm_cpp.*)))
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(HOME)/cosma*/lib*/libcosma_pxgemm_cpp.*)))
  ifneq (,$(COSMAROOT))
    COSMAROOT := $(abspath $(dir $(COSMAROOT))/..)
  endif
  ifneq (,$(COSMAROOT))
    LIBS += -L$(COSMAROOT)/lib64 -L$(COSMAROOT)/lib -lcosma -lcosma_pxgemm_cpp -lcosma_prefixed_pxgemm -lcosta_scalapack -lcosta
    DFLAGS += __COSMA
    ifneq (,$(NVCC))
      LIBS += -lTiled-MM
    endif
  endif
endif
endif

ifneq (0,$(SCALAPACK))
ifneq (0,$(MPI))
  DFLAGS += __SCALAPACK
  ifneq (0,$(LEGACY))
    DFLAGS += __BLACS
  endif
  ifeq (0,$(shell echo $(SCALAPACK) | grep -q "^-*[0-9]\+$$"; echo $$?)) # number
    ifneq (-1,$(SCALAPACK))
      ifneq (1,$(SCALAPACK))
        DFLAGS += __SCALAPACK$(SCALAPACK)
      endif
    else
      SCALAPACKDIR := $(HOME)/scalapack-2.0.2
    endif
    ifeq (,$(SCALAPACKDIR))
      SCALAPACKDIR := $(MKLROOT)/lib/intel64
      SCALAPACKLIB := mkl_scalapack_lp64
    else
      ifeq (,$(SCALAPACKLIB))
        SCALAPACKLIB := scalapack
      endif
      LIBS += -L$(SCALAPACKDIR)
    endif
  else # NaN
    SCALAPACKDIR := $(SCALAPACK)
    SCALAPACKLIB := scalapack
    LIBS += -L$(SCALAPACKDIR)
  endif
endif
endif

ifneq (0,$(NDEBUG))
  DFLAGS += NDEBUG
  ifneq (1,$(NDEBUG)) # CP2K and DBCSR
  else # only DBCSR
    ifeq (,$(wildcard $(CP2KHOME)/.inject.sh))
      INJECT := $(shell printf '$(CHAR_HASH)!/usr/bin/env bash\nif [ "$$4" ]; then\n\tif [ "$$(echo "$${@:4}" | sed -n "/$$1/p" 2>/dev/null)" ]; then\n\t\texec $$3 $$2 "$${@:4}"\n\telif [ "$$1" ]; then\n\t\texec $$3 "$${@:4}"\n\telse\n\t\texec $$3 $$2 "$${@:4}"\n\tfi\nelse\n\texec $$3\nfi\n' >$(CP2KHOME)/.inject.sh)
    endif
    ifneq (,$(wildcard $(CP2KHOME)/.inject.sh))
      INJECT := $(shell chmod +x $(CP2KHOME)/.inject.sh)
      FC := $(CP2KHOME)/.inject.sh dbcsr_ -DNDEBUG $(FC)
    endif
  endif
endif

# Diagnostic message to be turned off
DIAG_DISABLE := 8290,8291,10010,10212,10411,10448,11060

# Make C Compiler version number available
CC_VERSION := $(shell $(CC) --version 2> /dev/null | head -n1 | sed "s/..* \([0-9][0-9]*\.[0-9][0-9]*\.*[0-9]*\)[ \S]*.*/\1/")
CC_VERSION_NUM := $(call version, \
  $(shell echo "$(CC_VERSION)" | cut -d. -f1), \
  $(shell echo "$(CC_VERSION)" | cut -d. -f2), \
  $(shell echo "$(CC_VERSION)" | cut -d. -f3))

# Make Fortran Compiler version number available
FC_VERSION := $(shell $(FC) --version 2> /dev/null | head -n1 | sed "s/..* \([0-9][0-9]*\.[0-9][0-9]*\.*[0-9]*\)[ \S]*.*/\1/")
FC_VERSION_NUM := $(call version, \
  $(shell echo "$(FC_VERSION)" | cut -d. -f1), \
  $(shell echo "$(FC_VERSION)" | cut -d. -f2), \
  $(shell echo "$(FC_VERSION)" | cut -d. -f3))

# LEGACY support may depend on some VERSION_NUM
ifeq (0,$(LEGACY))
  ifeq (0,$(INTEL))
  ifneq (0,$(MPI))
  ifneq (0,$(GNU))
    ifneq (,$(I_MPI_ROOT))
      ifeq (,$(GNUVER))
        GNUVERS := $(shell echo "$(notdir \
          $(wildcard $(I_MPI_ROOT)/include/mpi/gfortran/*) \
          $(wildcard $(I_MPI_ROOT)/include/gfortran/*))" \
          | xargs -n1 | sort -t. -n -k1,1 -k2,2 -k3,3)
        GNUVINT := $(foreach GNUVER,$(GNUVERS),$(call version, \
          $(shell echo "$(GNUVER)" | cut -d. -f1), \
          $(shell echo "$(GNUVER)" | cut -d. -f2), \
          $(shell echo "$(GNUVER)" | cut -d. -f3)))
        ifneq (0,$(shell echo "$$(($(lastword $(GNUVINT))<$(FC_VERSION_NUM)))"))
          GNUVER := $(lastword $(GNUVERS))
        endif
      endif
      ifneq (,$(GNUVER))
        ifneq (,$(wildcard $(I_MPI_ROOT)/include/mpi/gfortran/$(GNUVER)))
          IFLAGS += $(I_MPI_ROOT)/include/mpi/gfortran/$(GNUVER)
        else ifneq (,$(wildcard $(I_MPI_ROOT)/include/gfortran/$(GNUVER)))
          IFLAGS += $(I_MPI_ROOT)/include/gfortran/$(GNUVER)
        endif
      endif
    else
      MPIROOT=$dir $(dir $(call which,$(FC))))
      ifneq (,$(wildcard $(MPIROOT)/lib/*.mod))
        IFLAGS += $(MPIROOT)/lib
      endif
    endif
  endif
  endif
  endif
else # legacy
  DFLAGS += __HAS_NO_MPI_MOD
endif

MIC ?= 0
ifeq (0,$(GNU)) # Intel
  ifeq (0,$(INTEL))
    $(info ================================================================================)
    $(info This ARCH file relies on Intel Compiler and Libraries. Please try the following:)
    $(info $$ source /opt/intel/oneapi/setvars.sh)
    $(info ================================================================================)
    $(error Intel Development Tools not found!)
  endif
  ifneq (0,$(shell echo "$$((2 > $(DBG)))"))
    ifeq (1,$(AVX))
      TARGET := -xAVX
      TGT := snb
    else ifeq (2,$(AVX))
      TARGET := -march=core-avx2
      TGT := hsw
    else ifeq (3,$(AVX))
      ifeq (,$(MIC))
        TARGET := -xCOMMON-AVX512
        TGT := hsw
      else ifneq (0,$(MIC))
        TARGET := -xMIC-AVX512
        TGT := knl
      else
        TARGET := -xCORE-AVX512
        ifeq (1,$(INTEL))
          TARGET += -qopt-zmm-usage=$(if $(filter-out 0,$(VMAX)),high,low)
        endif
        TGT := skx
      endif
    else ifneq (0,$(SSE))
      TARGET := -xSSE3
    else
      TARGET := -xHost
      ifneq (,$(shell grep -om1 '\bavx512vl\b' /proc/cpuinfo))
        ifeq (1,$(INTEL))
          TARGET += -qopt-zmm-usage=$(if $(filter-out 0,$(VMAX)),high,low)
        endif
        TGT := skx
      else ifneq (,$(shell grep -om1 '\bavx2\b' /proc/cpuinfo))
        TGT := hsw
      else ifneq (,$(shell grep -om1 '\bavx\b' /proc/cpuinfo))
        TGT := snb
      endif
    endif
  endif
  ifeq (0,$(DBG))
    FCFLAGS  += -align array64byte     $(FPFMODEL) $(FPFLAGS)
    CFLAGS   += -fno-alias -ansi-alias $(FPCMODEL) $(FPFLAGS)
    CXXFLAGS += -fno-alias -ansi-alias $(FPCMODEL) $(FPFLAGS)
    OPT ?= 2
    #OPTFLAGS += -qoverride_limits
    ifeq (0,$(MATMUL))
      OPTFLAGS += -qopt-matmul
    endif
    ifneq (0,$(IPO))
      IPOFLAGS += -ipo
    else ifeq (0,$(IPO))
      LDFLAGS += -no-ipo
    endif
  else # debug
    ifeq (1,$(INTEL))
      CXXFLAGS += -debug
      FCFLAGS  += -debug
      CFLAGS   += -debug
    endif
    OPT ?= 0
  endif
  ifneq (0,$(FPE))
    FCFLAGS += -fpe0 # debugging NaNs
  endif
  FCFLAGS += -free -fpp
  DFLAGS += __INTEL
  ifneq (0,$(LEGACY))
    DFLAGS += __F2008
  endif
  MKL_OMPRTL := intel
  MKL_FCRTL := intel
  RANLIB := xiar -s
  AR := xiar -r
else # GNU GCC
  ifeq (,$(MKLROOT))
    $(info ================================================================================)
    $(info This ARCH file relies on Intel Libraries. Please try the following:)
    $(info $$ source /opt/intel/oneapi/mkl/latest/env/vars.sh)
    $(info $$ source /opt/intel/oneapi/mpi/latest/env/vars.sh)
    $(info ================================================================================)
    $(error Intel MKL not found!)
  endif
  ifneq (0,$(shell echo "$$((2 > $(DBG)))"))
    ifeq (1,$(AVX))
      TARGET := -mavx
      TGT := snb
    else ifeq (2,$(AVX))
      TARGET := -march=core-avx2
      TGT := hsw
      ifneq (0,$(VMAX))
        TARGET += -mprefer-vector-width=256
      endif
    else ifeq (3,$(AVX))
      TARGET := -mfma -mavx512f -mavx512cd
      ifneq (,$(filter-out 0,$(MIC))) # AVX512/MIC
        TARGET += -mavx512pf -mavx512er
        ifneq (0,$(VMAX))
          TARGET += -mprefer-vector-width=512
        endif
        TGT := knl
      else # AVX512/Core
        TARGET += -mavx512dq -mavx512bw -mavx512vl
        ifneq (0,$(VMAX))
          TARGET += -mprefer-vector-width=512
        endif
        TGT := skx
      endif
    else ifneq (0,$(SSE))
      TARGET := -mSSE3
    else
      TARGET := -march=native -mtune=native
      ifneq (,$(shell grep -om1 '\bavx512vl\b' /proc/cpuinfo))
        ifneq (0,$(VMAX))
          TARGET += -mprefer-vector-width=512
        endif
        TGT := skx
      else ifneq (,$(shell grep -om1 '\bavx2\b' /proc/cpuinfo))
        ifneq (0,$(VMAX))
          TARGET += -mprefer-vector-width=256
        endif
        TGT := hsw
      else ifneq (,$(shell grep -om1 '\bavx\b' /proc/cpuinfo))
        TGT := snb
      endif
    endif
  endif
  FCFLAGS += -ffree-form -ffree-line-length-none
  FCFLAGS += -Wno-argument-mismatch #-fallow-argument-mismatch
  ifeq (0,$(DBG))
    OPTFLAGS += -funroll-loops -ftree-vectorize
    #FCFLAGS += -fstack-arrays
    ifeq (0,$(MATMUL))
      FCFLAGS += -fexternal-blas -fblas-matmul-limit=4
    endif
    ifneq (0,$(IPO))
      IPOFLAGS += -flto -Wl,-flto -Wno-lto-type-mismatch
    endif
    OPT ?= 3
  else # debug
    FCFLAGS += \
      -fimplicit-none -fsanitize=leak -fcheck=all -finit-derived -finit-real=snan -finit-integer=-42 -finline-matmul-limit=0 \
      -Werror=aliasing -Werror=ampersand -Werror=c-binding-type -Werror=intrinsics-std -Werror=line-truncation -Werror=tabs \
      -Werror=target-lifetime -Werror=underflow -Werror=unused-but-set-variable -Werror=conversion -Werror=unused-variable \
      -Werror=zerotrip -Wintrinsic-shadow #-Warray-temporaries
    ifneq (1,$(DBG))
      ifeq (,$(NVCC))
        FCFLAGS += -Werror=uninitialized -Werror=unused-dummy-argument -Wno-maybe-uninitialized
      endif
      FCFLAGS += -std=f2008 #-Werror=realloc-lhs-all
    endif
    OPT ?= 0
  endif
  ifneq (0,$(FPE))
    FCFLAGS += -ffpe-trap=invalid,zero,overflow -fsignaling-nans
    CFLAGS += -fsignaling-nans
  endif
  MKL_OMPRTL := gnu
  MKL_FCRTL := gf
  INTEL ?= 0
  RANLIB := gcc-ranlib
  AR := gcc-ar -r
endif

ifneq (,$(TGT))
  XCFG := $(CFG)-$(TGT)
else
  XCFG := $(CFG)
endif
ifneq (0,$(OMP))
  XCFGOMP := $(XCFG)-omp
else
  XCFGOMP := $(XCFG)
endif

$(info ================================================================================)
$(info Using the following libraries:)
ifneq (0,$(MKL)) # incl. undefined
ifneq (,$(MKLROOT))
  $(info MKLROOT=$(MKLROOT))
endif
endif
ifneq (0,$(LIBXSMM)) # incl. undefined
  ifneq (,$(wildcard $(CP2KHOME)/../libxsmm/Makefile))
    LIBXSMMROOT ?= $(abspath $(CP2KHOME)/../libxsmm)
  else ifneq (,$(wildcard $(CP2KHOME)/../libxsmm-master/Makefile))
    LIBXSMMROOT ?= $(abspath $(CP2KHOME)/../libxsmm-master)
  else ifneq (,$(wildcard $(CP2KHOME)/../libxsmm-*/Makefile))
    LIBXSMMROOT ?= $(abspath $(dir $(lastword $(sort $(wildcard $(CP2KHOME)/../libxsmm-*/Makefile)))))
  else ifneq (,$(wildcard $(HOME)/libxsmm/Makefile))
    LIBXSMMROOT ?= $(abspath $(HOME)/libxsmm)
  else ifneq (,$(wildcard $(HOME)/libxsmm-master/Makefile))
    LIBXSMMROOT ?= $(abspath $(HOME)/libxsmm-master)
  else ifneq (,$(wildcard $(HOME)/libxsmm-*/Makefile))
    LIBXSMMROOT ?= $(abspath $(dir $(lastword $(sort $(wildcard $(HOME)/libxsmm-*/Makefile)))))
  else ifneq (,$(wildcard $(TOOLSRC)/toolchain/build/libxsmm*/Makefile))
    LIBXSMMROOT ?= $(abspath $(dir $(lastword $(sort $(wildcard $(TOOLSRC)/toolchain/build/libxsmm*/Makefile)))))
  endif
  ifeq (/,$(LIBXSMMROOT))
    LIBXSMMROOT := $(NULL)
  endif
  ifneq (,$(LIBXSMMROOT))
    $(info LIBXSMMROOT=$(LIBXSMMROOT))
  endif
endif
ifneq (0,$(LIBINT)) # incl. undefined
  ifneq (,$(wildcard $(LIBINT_BASEDIR)/$(XCFG)))
    LIBINTROOT ?= $(abspath $(LIBINT_BASEDIR)/$(XCFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../libint/$(XCFG)))
    LIBINTROOT ?= $(abspath $(CP2KHOME)/../libint/$(XCFG))
  else ifneq (,$(wildcard $(HOME)/libint/$(XCFG)))
    LIBINTROOT ?= $(abspath $(HOME)/libint/$(XCFG))
  else ifneq (0,$(GNU))
    ifneq (,$(wildcard $(LIBINT_BASEDIR)/gnu))
      LIBINTROOT ?= $(abspath $(LIBINT_BASEDIR)/gnu)
    else ifneq (,$(wildcard $(CP2KHOME)/../libint/gnu))
      LIBINTROOT ?= $(abspath $(CP2KHOME)/../libint/gnu)
    else ifneq (,$(wildcard $(HOME)/libint/gnu))
      LIBINTROOT ?= $(abspath $(HOME)/libint/gnu)
    endif
  else ifneq (0,$(INTEL))
    ifneq (,$(wildcard $(LIBINT_BASEDIR)/intel))
      LIBINTROOT ?= $(abspath $(LIBINT_BASEDIR)/intel)
    else ifneq (,$(wildcard $(CP2KHOME)/../libint/intel))
      LIBINTROOT ?= $(abspath $(CP2KHOME)/../libint/intel)
    else ifneq (,$(wildcard $(HOME)/libint/intel))
      LIBINTROOT ?= $(abspath $(HOME)/libint/intel)
    endif
  endif
  ifeq (/,$(LIBINTROOT))
    LIBINTROOT := $(NULL)
  endif
  ifneq (,$(LIBINTROOT))
    $(info LIBINTROOT=$(LIBINTROOT))
  endif
endif
ifneq (0,$(PLUMED)) # incl. undefined
  ifneq (,$(wildcard $(CP2KHOME)/../plumed/$(XCFG)))
    PLUMEDROOT ?= $(abspath $(CP2KHOME)/../plumed/$(XCFG))
  else ifneq (,$(wildcard $(HOME)/plumed/$(XCFG)))
    PLUMEDROOT ?= $(abspath $(HOME)/plumed/$(XCFG))
  else ifneq (0,$(GNU))
    ifneq (,$(wildcard $(CP2KHOME)/../plumed/gnu))
      PLUMEDROOT ?= $(abspath $(CP2KHOME)/../plumed/gnu)
    else ifneq (,$(wildcard $(HOME)/plumed/gnu))
      PLUMEDROOT ?= $(abspath $(HOME)/plumed/gnu)
    endif
  else ifneq (0,$(INTEL))
    ifneq (,$(wildcard $(CP2KHOME)/../plumed/intel))
      PLUMEDROOT ?= $(abspath $(CP2KHOME)/../plumed/intel)
    else ifneq (,$(wildcard $(HOME)/plumed/intel))
      PLUMEDROOT ?= $(abspath $(HOME)/plumed/intel)
    endif
  endif
  ifeq (/,$(PLUMEDROOT))
    PLUMEDROOT := $(NULL)
  endif
  ifneq (,$(PLUMEDROOT))
    $(info PLUMEDROOT=$(PLUMEDROOT))
  endif
endif
ifneq (0,$(LIBXC)) # incl. undefined
  ifneq (,$(wildcard $(CP2KHOME)/../libxc/$(XCFG)))
    LIBXCROOT ?= $(abspath $(CP2KHOME)/../libxc/$(XCFG))
  else ifneq (,$(wildcard $(HOME)/libxc/$(XCFG)))
    LIBXCROOT ?= $(abspath $(HOME)/libxc/$(XCFG))
  else ifneq (0,$(GNU))
    ifneq (,$(wildcard $(CP2KHOME)/../libxc/gnu))
      LIBXCROOT ?= $(abspath $(CP2KHOME)/../libxc/gnu)
    else ifneq (,$(wildcard $(HOME)/libxc/gnu))
      LIBXCROOT ?= $(abspath $(HOME)/libxc/gnu)
    endif
  else ifneq (0,$(INTEL))
    ifneq (,$(wildcard $(CP2KHOME)/../libxc/intel))
      LIBXCROOT ?= $(abspath $(CP2KHOME)/../libxc/intel)
    else ifneq (,$(wildcard $(HOME)/libxc/intel))
      LIBXCROOT ?= $(abspath $(HOME)/libxc/intel)
    endif
  endif
  ifeq (/,$(LIBXCROOT))
    LIBXCROOT := $(NULL)
  endif
  ifneq (,$(LIBXCROOT))
    $(info LIBXCROOT=$(LIBXCROOT))
  endif
endif
ifneq (0,$(ELPA)) # incl. undefined
  ifneq (,$(wildcard $(CP2KHOME)/../elpa/$(XCFGOMP)))
    ELPAROOT ?= $(abspath $(CP2KHOME)/../elpa/$(XCFGOMP))
  else ifneq (,$(wildcard $(HOME)/elpa/$(XCFGOMP)))
    ELPAROOT ?= $(abspath $(HOME)/elpa/$(XCFGOMP))
  else ifneq (0,$(OMP))
    ifneq (0,$(GNU))
      ifneq (,$(wildcard $(CP2KHOME)/../elpa/gnu-omp))
        ELPAROOT ?= $(abspath $(CP2KHOME)/../elpa/gnu-omp)
      else ifneq (,$(wildcard $(HOME)/elpa/gnu-omp))
        ELPAROOT ?= $(abspath $(HOME)/elpa/gnu-omp)
      endif
    else ifneq (0,$(INTEL))
      ifneq (,$(wildcard $(CP2KHOME)/../elpa/intel-omp))
        ELPAROOT ?= $(abspath $(CP2KHOME)/../elpa/intel-omp)
      else ifneq (,$(wildcard $(HOME)/elpa/intel-omp))
        ELPAROOT ?= $(abspath $(HOME)/elpa/intel-omp)
      endif
    endif
  else ifneq (0,$(GNU))
    ifneq (,$(wildcard $(CP2KHOME)/../elpa/gnu))
      ELPAROOT ?= $(abspath $(CP2KHOME)/../elpa/gnu)
    else ifneq (,$(wildcard $(HOME)/elpa/gnu))
      ELPAROOT ?= $(abspath $(HOME)/elpa/gnu)
    endif
  else ifneq (0,$(INTEL))
    ifneq (,$(wildcard $(CP2KHOME)/../elpa/intel))
      ELPAROOT ?= $(abspath $(CP2KHOME)/../elpa/intel)
    else ifneq (,$(wildcard $(HOME)/elpa/intel))
      ELPAROOT ?= $(abspath $(HOME)/elpa/intel)
    endif
  endif
  ifneq (,$(ELPAROOT))
    $(info ELPAROOT=$(ELPAROOT))
  endif
endif
ifneq (0,$(COSMA)) # incl. undefined
ifneq (,$(COSMAROOT))
  $(info COSMAROOT=$(COSMAROOT))
endif
endif
$(info ================================================================================)

DBG_FLAG := -g
OPT1 := $(shell echo "$$((1<$(OPT)?1:$(OPT)))")
OPT2 := $(shell echo "$$((2<$(OPT)?2:$(OPT)))")
ifeq (0,$(ATTRIBS))
  DFLAGS += CP_DISABLE_ATTRIBS
endif

SYM ?= $(DBG)
ifneq (0,$(SYM))
  LDFLAGS += -Wl,--export-dynamic
  ifeq (0,$(GNU))
  ifneq (0,$(shell echo "$$((3 > $(OPT)))"))
    ifneq (0,$(LEGACY))
      DFLAGS += __USE_CP2K_TRACE
    endif
    OPTFLAGS += -traceback
  endif
  endif
  OPTFLAGS += $(DBG_FLAG)
endif

FYPP := $(wildcard $(TOOLSRC)/build_utils/fypp)
ifeq (0,$(GNU))
  # workaround for certain bits introduced by GCC 7.0
  ifneq (0,$(shell echo "$$((180002 >= $(CC_VERSION_NUM) && 0 != $(CC_VERSION_NUM)))"))
    CFLAGS += -D_Float128=__float128
    FPCMODEL ?= precise
    FPFMODEL ?= source
  endif
  ifneq (,$(strip $(FPCMODEL)))
    FPCMODEL := -fp-model $(FPCMODEL)
  endif
  ifneq (,$(strip $(FPFMODEL)))
    FPFMODEL := -fp-model $(FPFMODEL)
  endif
endif
BEEP ?= 1

ifneq (0,$(OMP))
  ifeq (0,$(GNU))
    FCFLAGS += -threads #-parallel
    LDFLAGS += -threads
  endif
  ifneq (0,$(INTEL))
    OPTFLAGS += -qopenmp
  else
    OPTFLAGS += -fopenmp
  endif
endif

ifneq (,$(LIBINTROOT))
  DFLAGS += __LIBINT __MAX_CONTR=4
  IFLAGS += $(LIBINTROOT)/include
  ifneq (,$(wildcard $(LIBINTROOT)/lib64/libint2.*))
    LIBS += $(LIBINTROOT)/lib64/libint2.a
  else ifneq (,$(wildcard $(LIBINTROOT)/lib/libint2.*))
    LIBS += $(LIBINTROOT)/lib/libint2.a
  else # LIBINT1
    LIBS += $(LIBINTROOT)/lib/libderiv.a $(LIBINTROOT)/lib/libint.a
    DFLAGS += __LIBINT_MAX_AM=7 __LIBDERIV_MAX_AM1=6
  endif
endif

ifneq (,$(LIBXCROOT))
  DFLAGS += __LIBXC
  IFLAGS += $(LIBXCROOT)/include
  ifneq (,$(wildcard $(LIBXCROOT)/lib64/libxcf03.a))
    LIBS += $(LIBXCROOT)/lib64/libxcf03.a
  else ifneq (,$(wildcard $(LIBXCROOT)/lib/libxcf03.a))
    LIBS += $(LIBXCROOT)/lib/libxcf03.a
  endif
  ifneq (,$(wildcard $(LIBXCROOT)/lib64/libxc.a))
    LIBS += $(LIBXCROOT)/lib64/libxc.a
  else ifneq (,$(wildcard $(LIBXCROOT)/lib/libxc.a))
    LIBS += $(LIBXCROOT)/lib/libxc.a
  endif
endif

ifneq (,$(PLUMEDROOT))
  DFLAGS += __PLUMED2
  # avoid duplicated libraries (-ldl -lstdc++)
  LIBS   += $(PLUMEDROOT)/lib/libplumed.a -lz
endif

ifneq (,$(ELPAROOT))
ifneq (0,$(ELPA))
  ifneq (0,$(CUDA))
    DFLAGS += __ELPA_NVIDIA_GPU
  endif
  ifneq (1,$(ELPA))
    DFLAGS += __ELPA=$(ELPA)
  else
    DFLAGS += __ELPA
  endif
  ELPAINCDIR := $(dir $(shell ls -1 $(ELPAROOT)/include/*/elpa/elpa_*constants.h | head -n1))
  ELPAMODDIR := $(ELPAINCDIR)../modules
  IFLAGS += $(ELPAINCDIR) $(ELPAMODDIR)
  LIBS += $(ELPAROOT)/lib/libelpa.a
  # in case ELPA is built with OpenMP
  ifeq (0,$(OMP))
    LIBS += -Wl,--as-needed -l$(OMPRT) -Wl,--no-as-needed
  endif
endif
endif

ifneq (,$(LIBXSMMROOT))
  # 1: SMMs, 2: 1+UnreleasedFeat, 3: 2+AllGEMM
  LIBXSMM ?= 1
  ifneq (0,$(LIBXSMM))
    LIBXSMM_DSTDIR := $(CP2KHOME)/$(LIBDIRNAME)/$(ARCH)/$(ONEVERSION)/libxsmm
    DFLAGS += __LIBXSMM=$(LIBXSMM)
    ifeq (0,$(GNU))
      DFLAGS += _OPENMP_SIMD
      OPTFLAGS += -qopenmp-simd
    else
      ifneq (0,$(DBG))
      # suppress "Fortran runtime warning:"
        LDFLAGS += -Wl,--wrap=_gfortran_runtime_warning_at
      endif
      ifeq (,$(filter _0_ __,_$(SIMD)_)) # force-enable with SIMD=1
      # GNU: https://github.com/cp2k/dbcsr/issues/217
        DFLAGS += _OPENMP_SIMD
        OPTFLAGS += -fopenmp-simd
      endif
    endif

    # link libxsmmext (needed at least in case of WRAP)
    LIBS += $(LIBXSMM_DSTDIR)/lib/libxsmmf.a
    LIBS += $(LIBXSMM_DSTDIR)/lib/libxsmmext.a
    LIBS += $(LIBXSMM_DSTDIR)/lib/libxsmm.a
    IFLAGS += $(LIBXSMM_DSTDIR)/include

    # account for OpenMP-enabled libxsmmext routines
    ifeq (0,$(OMP))
      DFLAGS += DBCSR_LIBXSMM_GEMM_BATCH=libxsmm_gemm_batch_omp
      ifeq (1,$(MKL))
        LIBS += -l$(OMPRT)
      else ifeq (0,$(MKL))
        LIBS += -l$(OMPRT)
      endif
    endif
    # enable additional use cases for LIBXSMM
    ifneq (0,$(shell echo "$$((1 < $(LIBXSMM)))"))
      BIGVERNUM := echo "99" > version.txt
      # substitute all GEMM calls with LIBXSMM
      WRAP ?= $(shell echo "$$(((2<$(LIBXSMM))*($(LIBXSMM)-2)))")
      ifneq (0,$(WRAP))
        ifneq (0,$(shell echo "$$((2<$(WRAP)))"))
          LDFLAGS += -Wl,--wrap=dgemm_,--wrap=sgemm_,--wrap=dgemv_,--wrap=sgemv_
          ifneq (0,$(shell echo "$$((3<$(WRAP)))"))
            LIBS += $(LIBXSMM_DSTDIR)/lib/libxsmmnoblas.a
          endif
        else
          LDFLAGS += -Wl,--wrap=dgemm_,--wrap=sgemm_
        endif
      endif
    else
      BIGVERNUM := rm -f version.txt
    endif
    WRAP ?= 0
    JIT ?= 1
    ifneq (0,$(shell echo "$$((0>=$(JIT)))"))
      LIBXSMM_MNK := "23, 6, 14 16 29, 14 32 29, 5 32 13 24 26, 9 32 22, 64, 78, 16 29 55, 32 29 55, 12, 4 5 7 9 13 25 26 28 32 45"
    endif
-include always-build
.PHONY: always-build
always-build:
	@$(BIGVERNUM)
	@mkdir -p $(LIBXSMM_DSTDIR)
	@$(MAKE) -C $(LIBXSMM_DSTDIR) \
		-f "$(LIBXSMMROOT)/Makefile" --no-print-directory \
		CXX="$(XCXX)" CC="$(XCC)" FC="$(XFC)" "AR=$(firstword $(AR))" WERROR=0 \
		STATIC=1 JIT=$(JIT) SYM=$(SYM) DBG=$(DBG) OPT=$(OPT) IPO=0 INIT=0 MALLOC=0 WRAP=$(WRAP) \
		MNK=$(LIBXSMM_MNK) M=$(LIBXSMM_M) N=$(LIBXSMM_N) K=$(LIBXSMM_K) PRECISION=2 VTUNE=0 \
		CTARGET="$(TARGET)" SSE=$(SSE) AVX=$(AVX) MIC=$(MIC) INTEL=$(INTEL) GNU=$(GNU) \
		$(if $(filter-out 0,$(shell echo "$$((3<$(WRAP)))")),BLAS=0) >&2
  endif
endif

ifeq (1,$(MKL_DIRECT))
  DFLAGS += MKL_DIRECT_CALL_SEQ
endif

ifeq (1,$(MKL)) # sequential
  MKL_THREADS := sequential
else ifneq (0,$(MKL)) # multi-threaded
  MKL_THREADS := $(MKL_OMPRTL)_thread
  ifeq (0,$(OMP))
    LIBS += -l$(OMPRT)
  endif
endif
ifneq (0,$(MKL))
  DFLAGS += __MKL __FFTW3
  ifeq (,$(MKL_INCFILE))
    IFLAGS += $(MKLROOT)/include
    ifneq (,$(wildcard $(MKLROOT)/include/fftw))
      IFLAGS += $(MKLROOT)/include/fftw
    endif
  else
    IFLAGS += $(dir $(MKL_INCFILE))
    ifneq (,$(wildcard $(dir $(MKL_INCFILE))/fftw))
      IFLAGS += $(dir $(MKL_INCFILE))/fftw
    endif
  endif
  ifeq (0,$(MKL_STATIC))
    LIBS += -L$(MKLROOT)/lib/intel64
    ifneq (0,$(MPI))
      LIBS += -l$(SCALAPACKLIB) -lmkl_$(MKL_FCRTL)_lp64 -lmkl_core -lmkl_$(MKL_THREADS) -lmkl_blacs_$(MKL_MPIRTL)_lp64
    else
      LIBS += -lmkl_$(MKL_FCRTL)_lp64 -lmkl_core -lmkl_$(MKL_THREADS)
    endif
  else # static
    ifneq (0,$(MPI))
      LIBS += \
        -Wl,--start-group \
          $(SCALAPACKDIR)/lib$(SCALAPACKLIB).a \
          $(MKLROOT)/lib/intel64/libmkl_$(MKL_FCRTL)_lp64.a \
          $(MKLROOT)/lib/intel64/libmkl_core.a \
          $(MKLROOT)/lib/intel64/libmkl_$(MKL_THREADS).a \
          $(MKLROOT)/lib/intel64/libmkl_blacs_$(MKL_MPIRTL)_lp64.a \
        -Wl,--end-group
    else
      LIBS += \
        -Wl,--start-group \
          $(MKLROOT)/lib/intel64/libmkl_$(MKL_FCRTL)_lp64.a \
          $(MKLROOT)/lib/intel64/libmkl_core.a \
          $(MKLROOT)/lib/intel64/libmkl_$(MKL_THREADS).a \
        -Wl,--end-group
    endif
  endif
  LIBS += -Wl,--as-needed
  LIBS += -lpthread -ldl
  ifneq (0,$(INTEL))
    LIBS += -limf
  else
    LIBS += -lm
  endif
  LIBS += -Wl,--no-as-needed
endif

ifneq (0,$(LEGACY))
  DFLAGS += __HAS_ISO_C_BINDING
endif
# general include paths
#IFLAGS +=

# Define __INTEL_COMPILER in case of external preprocessing because some source (pw/fft/fftw3_lib.F)
# toggles code using this symbol, but of course the cpp preprocessor is not defining this symbol.
ifneq (,$(strip $(CPP)))
  CPPFLAGS += -C $(call prefix_iflags,$(IFLAGS)) $(call prefix_dflags,$(DFLAGS) __INTEL_COMPILER) -P -traditional
endif

# finalize flags common to CXX, CC, and FC
OPTFLAGS := $(TARGET) $(OPTFLAGS) -O$(OPT)

ifneq (,$(filter-out 0,$(OCL) $(CUDA)))
  ifneq (0,$(OCL))
    DFLAGS += __ACC __DBCSR_ACC
    ifneq (1,$(OCL))
      OPENCL_DBM_CMN := $(wildcard $(DBCSRSRC)/acc/opencl/common/*.h)
      OPENCL_DBM_SRC := $(CP2KHOME)/src/dbm/dbm_multiply_opencl.cl
      OPENCL_DBM_GEN := $(DBCSRSRC)/acc/opencl/acc_opencl.sh
$(OPENCL_DBM_SRC).h: $(OPENCL_DBM_GEN) $(OPENCL_DBM_SRC) $(OPENCL_DBM_CMN)
	$(OPENCL_DBM_GEN) -b 6 -p "" $(OPENCL_DBM_SRC) $@
dbm_multiply_opencl.o: dbm_multiply_opencl.c $(ALL_HEADERS) $(OPENCL_DBM_SRC).h
	$(CC) -c $(CFLAGS) $<
      DFLAGS += __OFFLOAD_OPENCL
      # TODO: implement support or missing features for GRID and PW
      DFLAGS += __NO_OFFLOAD_GRID __NO_OFFLOAD_PW
      IFLAGS += $(EXTDBCSR)
    endif
    ifeq (Darwin,$(UNAME))
      LIBS += -framework OpenCL
    else
      ifneq (,$(CUDA_PATH))
        IFLAGS += $(CUDA_PATH)/include
        #LIBS += -L$(CUDA_PATH)/$(CUDA_LIBS)
      else ifneq (,$(wildcard $(OPENCL_ROOT)/include/CL/cl.h))
        OPENCL_LIBS := $(if $(wildcard $(OPENCL_ROOT)/lib64),lib64,lib)
        LIBS += -L$(OPENCL_ROOT)/$(OPENCL_LIBS)
        IFLAGS += $(OPENCL_ROOT)/include
      else ifneq (,$(wildcard $(OPENCL_ROOT)/include/sycl/CL/cl.h))
        OPENCL_LIBS := $(if $(wildcard $(OPENCL_ROOT)/lib64),lib64,lib)
        LIBS += -L$(OPENCL_ROOT)/$(OPENCL_LIBS) -L$(OPENCL_ROOT)/compiler/lib/intel64 -lintlc
        IFLAGS += $(OPENCL_ROOT)/include/sycl
      endif
      OCL_ICD_LOADER := $(firstword $(wildcard /usr/lib/*/libOpenCL.so.*))
      ifneq (,$(OCL_ICD_LOADER))
        LIBS += $(OCL_ICD_LOADER)
      else
        LIBS += -l:libOpenCL.so.1
      endif
    endif
    ACCFLAGS += $(CFLAGS)
    USE_ACCEL := opencl
    ACC := $(CC)
  else #ifneq (0,$(CUDA))
    ifneq (,$(CUDA_PATH))
      ifneq (undefined,$(origin GPUVER))
        ifneq (0,$(SYM))
          ACCFLAGS += $(DBG_FLAG)
        endif
        IFLAGS += $(CUDA_PATH)/include
        DFLAGS += __ACC __DBCSR_ACC __CUDA __OFFLOAD_CUDA __GRID_CUDA __DBM_CUDA __PW_GPU __PW_CUDA
        LIBS += -L$(CUDA_PATH)/$(CUDA_LIBS) -lcudart -lcublas -lcufft -lnvrtc -lcuda
        # consider omitting opt-level entirely due to extreme compilation time even when flag targets only the host compiler
        ACCFLAGS := -O$(OPT) $(addprefix -Xcompiler $(NULL),$(filter-out $(DBG_FLAG) -O$(OPT) -Wl%,$(OPTFLAGS))) $(call prefix_dflags,$(DFLAGS))
        NVCFLAGS := $(ACCFLAGS)
        NVFLAGS := $(ACCFLAGS)
        USE_ACCEL := cuda
        ACC := $(NVCC)
        IPO := 0
      else
        $(info ===================)
        $(info GPUVER not defined!)
        $(info ===================)
        $(error GPUVER)
      endif
    else
      $(info ===============)
      $(info NVCC not found!)
      $(info ===============)
      $(error NVCC)
    endif
  endif
else # ACC off
  ifeq (0,$(GNU))
  ifneq (0,$(LEGACY))
    OPTFLAGS += -qno-offload
  endif
  endif
endif

CXXFLAGS  += $(OPTFLAGS) $(IPOFLAGS) $(call prefix_dflags,$(DFLAGS)) $(call prefix_iflags,$(IFLAGS)) #-std=c++0x
CFLAGS    += $(OPTFLAGS) $(call prefix_dflags,$(DFLAGS)) $(call prefix_iflags,$(IFLAGS))
FCFLAGS   += $(OPTFLAGS) $(IPOFLAGS) $(call prefix_dflags,$(DFLAGS)) $(call prefix_iflags,$(IFLAGS))
LDFLAGS   += $(OPTFLAGS) $(IPOFLAGS) #-static-intel -static-libgcc -static-libstdc++

ifeq (0,$(GNU))
  CXXFLAGS  += -diag-disable $(DIAG_DISABLE)
  CFLAGS    += -diag-disable $(DIAG_DISABLE)
  FCFLAGS   += -diag-disable $(DIAG_DISABLE)
  LDFLAGS   += -diag-disable $(DIAG_DISABLE)
  # consider -nofor_main for legacy compiler
  LDFLAGS_C += -nofor-main
endif

# Collect all paths in LD_LIBRARY_PATH and LD_LIBRARY_PATH/stubs, and append to LIBS
LD_LIBRARY_PATH := $(wildcard $(subst :, ,$(LD_LIBRARY_PATH)))
LD_LIBSTUB_PATH := $(wildcard $(patsubst %,%/stubs,$(LD_LIBRARY_PATH)))
#LD_INCLUDE_PATH := $(wildcard $(patsubst %,$(abspath %/../include),$(LD_LIBRARY_PATH)))
LIBPATHS := $(foreach DIR,$(LD_LIBRARY_PATH),$(if $(filter -L$(DIR),$(LIBS)),$(NULL),-L$(DIR)))
LIBSTUBS := $(foreach DIR,$(LD_LIBSTUB_PATH),$(if $(filter -L$(DIR),$(LIBS)),$(NULL),-L$(DIR)))
LIBS += $(LIBPATHS) $(LIBSTUBS) -Wl,--as-needed -lstdc++ -Wl,--no-as-needed
#IFLAGS += $(INCPATHS)

cleanup = $(foreach FLAG,$1,$(FLAG))
LDFLAGS := $(filter-out -ipo -ipo-separate,$(call cleanup,$(LDFLAGS)))
CXXFLAGS := $(call cleanup,$(CXXFLAGS))
FCFLAGS := $(call cleanup,$(FCFLAGS))
CFLAGS := $(call cleanup,$(CFLAGS))
DFLAGS := $(call cleanup,$(DFLAGS))
IFLAGS := $(call cleanup,$(IFLAGS))

# apply ACC settings for CP2K/GRID code
OFFLOAD_TARGET := $(USE_ACCEL)
OFFLOAD_FLAGS := $(ACCFLAGS)
OFFLOAD_CC := $(ACC)

ifneq (,$(CSTD))
dbm_miniapp.o: dbm_miniapp.c $(ALL_HEADERS)
	$(CC) -c $(filter-out $(CSTD),$(CFLAGS)) $<
endif

ifneq (0,$(NDEBUG))
environment.o: environment.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90,$(NULL)))
	$(MAKE_FYPP)
	$(FC) -c $(filter-out -DNDEBUG,$(FCFLAGS)) -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
grid_library.o: grid_library.c $(ALL_HEADERS)
	$(CC) -c $(filter-out -DNDEBUG,$(CFLAGS)) $<
endif

# filter-out override_limits flag since IFORT can run out of memory (SIGKILL)
ifeq (1,$(INTEL))
ifneq (,$(filter -qoverride_limits,$(FCFLAGS)))
mp2_eri.o: mp2_eri.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90,$(NULL)))
	$(MAKE_FYPP)
	$(FC) -c $(filter-out -qoverride_limits,$(FCFLAGS)) -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
minimax_exp_k53.o: minimax_exp_k53.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90,$(NULL)))
	$(MAKE_FYPP)
	$(FC) -c $(filter-out -qoverride_limits,$(FCFLAGS)) -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
endif
mp2_optimize_ri_basis.o: mp2_optimize_ri_basis.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90,$(NULL)))
	$(MAKE_FYPP)
	$(FC) -c $(FCFLAGS) -O0 -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
endif

ifneq (,$(filter 0,$(GNU)))
ifneq (,$(filter-out 0 1,$(INTEL)))
ifneq (,$(filter-out 0,$(BEEP)))
pw_methods.o: pw_methods.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90,$(NULL)))
	$(MAKE_FYPP)
	$(FC) -c $(filter-out -qopenmp,$(FCFLAGS)) -D_OPENMP -recursive -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
xc.o: xc.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90,$(NULL)))
	$(MAKE_FYPP)
	$(FC) -c $(filter-out -qopenmp,$(FCFLAGS)) -D_OPENMP -recursive -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
endif
endif
endif
